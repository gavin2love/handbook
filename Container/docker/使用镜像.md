# 获取镜像
镜像可以从Dockers Hub 获取，使用命令docker pull。格式为：

	docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]

- 默认地址是 Docker Hub(docker.io)
- 仓库名即 <用户名>/<软件名>。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像

# 运行镜像

	docker run -it --rm ubuntu:18.04 bash
	
docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。
- -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。
-  --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。
-  ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。
-  bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。

# 列出镜像
	
	docker image ls 
	# 或者
	docker images


仓库名		  标签      镜像ID		   创建时间			镜像体积
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
nginx         latest    f6d0b4767a6c   2 months ago    133MB
hello-world   latest    bf756fb1ae65   14 months ago   13.3kB

## Docker 镜像是多层存储结构，可以继承、复用，不同镜像可能会拥有共同的层。因此实际镜像硬盘占用空间要比这个列表镜像大小的总和要小的多

你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。

	docker system df

## 虚悬镜像(dangling image)

由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：

	$ docker image ls -f dangling=true
	REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
	<none>              <none>              00285df0df87        5 days ago          342 MB
	
一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。

	docker image prune

# 删除本地镜像

需要删除所有仓库名为 redis 的镜像：

	docker rmi $(docker image ls -q redis)
	
或者删除所有在 mongo:3.2 之前的镜像：

	docker rmi $(docker image ls -q -f before=mongo:3.2)
	
没有打标签

	docker rmi `docker images -q | awk '/^<none>/ { print $3 }'`

镜像名包含关键字

	docker rmi --force `docker images | grep nginx | awk '{print $3}'`    //其中nginx为关键字

删除所有镜像

	docker rmi `docker images -q`

# Dockerfile 定制镜像

Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。
Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。


还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。

    在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：
    $ mkdir mynginx
    $ cd mynginx
    $ touch Dockerfile

其内容为：

    FROM nginx
    RUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html

这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。

- FROM 指定基础镜像
所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。
- RUN 执行命令
RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：

  - shell 格式：RUN <命令>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。
  - exec 格式：RUN ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。

## 构建镜像

    $ docker build -t nginx:v3 .
    Sending build context to Docker daemon 2.048 kB
    Step 1 : FROM nginx
     ---> e43d811ce2f4
    Step 2 : RUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html
     ---> Running in 9cdc27646c7b
     ---> 44aa4490ce2c
    Removing intermediate container 9cdc27646c7b
    Successfully built 44aa4490ce2c
从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。

这里我们使用了 docker build 命令进行镜像构建。其格式为：

	docker build [选项] <上下文路径/URL/->

在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。


## Dockerfile 指令
- COPY 复制文件
- ADD 更高级的复制文件
- CMD 容器启动命令
- ENTRYPOINT 入口点
- ENV 设置环境变量
- ARG 构建参数
- VOLUME 定义匿名卷
- EXPOSE 暴露端口
- WORKDIR 指定工作目录
- USER 指定当前用户
- HEALTHCHECK 健康检查
- ONBUILD 为他人作嫁衣裳
- LABEL 为镜像添加元数据
- SHELL 指令
- ockerfile 多阶段构建

